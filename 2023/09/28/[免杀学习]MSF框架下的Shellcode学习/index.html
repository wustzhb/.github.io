<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>[免杀学习]MSF框架分析之Windows Api的调用 | Lanb0's blog|一个默默无闻的网安爱好者</title><meta name="author" content="lanb0"><meta name="copyright" content="lanb0"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="分析windows X86的shellcode  MSF中用于windows x86平台的Shellcode模块 metasploit-framework&#x2F;external&#x2F;source&#x2F;shellcode&#x2F;windows&#x2F;x86&#x2F;src&#x2F;block at master · rapid7&#x2F;metasploit-fra">
<meta property="og:type" content="article">
<meta property="og:title" content="[免杀学习]MSF框架分析之Windows Api的调用">
<meta property="og:url" content="https://wustzhb.github.io/2023/09/28/[%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0]MSF%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84Shellcode%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Lanb0&#39;s blog|一个默默无闻的网安爱好者">
<meta property="og:description" content="分析windows X86的shellcode  MSF中用于windows x86平台的Shellcode模块 metasploit-framework&#x2F;external&#x2F;source&#x2F;shellcode&#x2F;windows&#x2F;x86&#x2F;src&#x2F;block at master · rapid7&#x2F;metasploit-fra">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wustzhb.github.io/img/head.jpg">
<meta property="article:published_time" content="2023-09-28T12:00:00.000Z">
<meta property="article:modified_time" content="2023-09-28T13:06:01.225Z">
<meta property="article:author" content="lanb0">
<meta property="article:tag" content="免杀">
<meta property="article:tag" content="MSF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wustzhb.github.io/img/head.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://wustzhb.github.io/2023/09/28/[%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0]MSF%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84Shellcode%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '[免杀学习]MSF框架分析之Windows Api的调用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-28 21:06:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于博主</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Lanb0's blog|一个默默无闻的网安爱好者"><span class="site-name">Lanb0's blog|一个默默无闻的网安爱好者</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于博主</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">[免杀学习]MSF框架分析之Windows Api的调用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-28T12:00:00.000Z" title="发表于 2023-09-28 20:00:00">2023-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-28T13:06:01.225Z" title="更新于 2023-09-28 21:06:01">2023-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%8D%E6%9D%80%E7%B3%BB%E5%88%97/">免杀系列</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%8D%E6%9D%80%E7%B3%BB%E5%88%97/Shellcode/">Shellcode</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>分析<code>windows X86</code>的shellcode</p>
</blockquote>
<p>MSF中用于windows x86平台的Shellcode模块</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/tree/master/external/source/shellcode/windows/x86/src/block">metasploit-framework&#x2F;external&#x2F;source&#x2F;shellcode&#x2F;windows&#x2F;x86&#x2F;src&#x2F;block at master · rapid7&#x2F;metasploit-framework · GitHub</a></p>
<p>调用任意API的汇编代码</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm">metasploit-framework&#x2F;external&#x2F;source&#x2F;shellcode&#x2F;windows&#x2F;x86&#x2F;src&#x2F;block&#x2F;block_api.asm at master · rapid7&#x2F;metasploit-framework · GitHub</a></p>
<p>反向tcp连接汇编代码</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm">metasploit-framework&#x2F;external&#x2F;source&#x2F;shellcode&#x2F;windows&#x2F;x86&#x2F;src&#x2F;block&#x2F;block_reverse_tcp.asm at master · rapid7&#x2F;metasploit-framework · GitHub</a></p>
<h1 id="block-api"><a href="#block-api" class="headerlink" title="block_api"></a>block_api</h1><p>这段代码是用于调用任意API的汇编代码，它可以在不依赖于任何API的情况下，根据模块名和函数名的哈希值来查找和执行目标API。</p>
<p>在整个shellcode中，这段代码的作用是可以让攻击者在目标机器上执行任意的Windows API，从而实现更多的功能和操作。例如，攻击者可以使用这段代码来调用MessageBoxA函数，弹出一个消息框，或者调用ShellExecute函数，打开一个网页或一个文件。这段代码也可以避免使用LoadLibrary和GetProcAddress等常见的API，从而降低被检测的风险。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">;-----------------------------------------------------------------------------;</span><br><span class="line">; Author: Stephen Fewer (stephen_fewer[at]harmonysecurity[dot]com)</span><br><span class="line">; Compatible: NT4 and newer</span><br><span class="line">; Architecture: x86</span><br><span class="line">; Size: 140 bytes</span><br><span class="line">;-----------------------------------------------------------------------------;</span><br><span class="line"></span><br><span class="line">[BITS 32]</span><br><span class="line"></span><br><span class="line">; Input: The hash of the API to call and all its parameters must be pushed onto stack.</span><br><span class="line">; Output: The return value from the API call will be in EAX.</span><br><span class="line">; Clobbers: EAX, ECX and EDX (ala the normal stdcall calling convention)</span><br><span class="line">; Un-Clobbered: EBX, ESI, EDI, ESP and EBP can be expected to remain un-clobbered.</span><br><span class="line">; Note: This function assumes the direction flag has allready been cleared via a CLD instruction.</span><br><span class="line">; Note: This function is unable to call forwarded exports.</span><br><span class="line"></span><br><span class="line">api_call:</span><br><span class="line">  pushad                     ; We preserve all the registers for the caller, bar EAX and ECX.</span><br><span class="line">  mov ebp, esp               ; Create a new stack frame</span><br><span class="line">  xor edx, edx               ; Zero EDX</span><br><span class="line">  mov edx, [fs:edx+0x30]     ; Get a pointer to the PEB</span><br><span class="line">  mov edx, [edx+0xc]         ; Get PEB-&gt;Ldr</span><br><span class="line">  mov edx, [edx+0x14]        ; Get the first module from the InMemoryOrder module list</span><br><span class="line">next_mod:                    ;</span><br><span class="line">  mov esi, [edx+0x28]        ; Get pointer to modules name (unicode string)</span><br><span class="line">  movzx ecx, word [edx+0x26] ; Set ECX to the length we want to check</span><br><span class="line">  xor edi, edi               ; Clear EDI which will store the hash of the module name</span><br><span class="line">loop_modname:                ;</span><br><span class="line">  xor eax, eax               ; Clear EAX</span><br><span class="line">  lodsb                      ; Read in the next byte of the name</span><br><span class="line">  cmp al, &#x27;a&#x27;                ; Some versions of Windows use lower case module names</span><br><span class="line">  jl not_lowercase           ;</span><br><span class="line">  sub al, 0x20               ; If so normalise to uppercase</span><br><span class="line">not_lowercase:               ;</span><br><span class="line">  ror edi, 0xd               ; Rotate right our hash value</span><br><span class="line">  add edi, eax               ; Add the next byte of the name</span><br><span class="line">  dec ecx</span><br><span class="line">  jnz loop_modname           ; Loop until we have read enough</span><br><span class="line">  ; We now have the module hash computed</span><br><span class="line">  push edx                   ; Save the current position in the module list for later</span><br><span class="line">  push edi                   ; Save the current module hash for later</span><br><span class="line">  ; Proceed to iterate the export address table,</span><br><span class="line">  mov edx, [edx+0x10]        ; Get this modules base address</span><br><span class="line">  mov eax, [edx+0x3c]        ; Get PE header</span><br><span class="line">  add eax, edx               ; Add the modules base address</span><br><span class="line">  mov eax, [eax+0x78]        ; Get export tables RVA</span><br><span class="line">  test eax, eax              ; Test if no export address table is present</span><br><span class="line">  jz get_next_mod1           ; If no EAT present, process the next module</span><br><span class="line">  add eax, edx               ; Add the modules base address</span><br><span class="line">  push eax                   ; Save the current modules EAT</span><br><span class="line">  mov ecx, [eax+0x18]        ; Get the number of function names</span><br><span class="line">  mov ebx, [eax+0x20]        ; Get the rva of the function names</span><br><span class="line">  add ebx, edx               ; Add the modules base address</span><br><span class="line">  ; Computing the module hash + function hash</span><br><span class="line">get_next_func:               ;</span><br><span class="line">  test ecx, ecx              ; Changed from jecxz to accomodate the larger offset produced by random jmps below</span><br><span class="line">  jz get_next_mod            ; When we reach the start of the EAT (we search backwards), process the next module</span><br><span class="line">  dec ecx                    ; Decrement the function name counter</span><br><span class="line">  mov esi, [ebx+ecx*4]       ; Get rva of next module name</span><br><span class="line">  add esi, edx               ; Add the modules base address</span><br><span class="line">  xor edi, edi               ; Clear EDI which will store the hash of the function name</span><br><span class="line">  ; And compare it to the one we want</span><br><span class="line">loop_funcname:               ;</span><br><span class="line">  xor eax, eax               ; Clear EAX</span><br><span class="line">  lodsb                      ; Read in the next byte of the ASCII function name</span><br><span class="line">  ror edi, 0xd               ; Rotate right our hash value</span><br><span class="line">  add edi, eax               ; Add the next byte of the name</span><br><span class="line">  cmp al, ah                 ; Compare AL (the next byte from the name) to AH (null)</span><br><span class="line">  jne loop_funcname          ; If we have not reached the null terminator, continue</span><br><span class="line">  add edi, [ebp-8]           ; Add the current module hash to the function hash</span><br><span class="line">  cmp edi, [ebp+0x24]        ; Compare the hash to the one we are searchnig for</span><br><span class="line">  jnz get_next_func          ; Go compute the next function hash if we have not found it</span><br><span class="line">  ; If found, fix up stack, call the function and then value else compute the next one...</span><br><span class="line">  pop eax                    ; Restore the current modules EAT</span><br><span class="line">  mov ebx, [eax+0x24]        ; Get the ordinal table rva</span><br><span class="line">  add ebx, edx               ; Add the modules base address</span><br><span class="line">  mov cx, [ebx+2*ecx]        ; Get the desired functions ordinal</span><br><span class="line">  mov ebx, [eax+0x1c]        ; Get the function addresses table rva</span><br><span class="line">  add ebx, edx               ; Add the modules base address</span><br><span class="line">  mov eax, [ebx+4*ecx]       ; Get the desired functions RVA</span><br><span class="line">  add eax, edx               ; Add the modules base address to get the functions actual VA</span><br><span class="line">  ; We now fix up the stack and perform the call to the desired function...</span><br><span class="line">finish:</span><br><span class="line">  mov [esp+0x24], eax        ; Overwrite the old EAX value with the desired api address for the upcoming popad</span><br><span class="line">  pop ebx                    ; Clear off the current modules hash</span><br><span class="line">  pop ebx                    ; Clear off the current position in the module list</span><br><span class="line">  popad                      ; Restore all of the callers registers, bar EAX, ECX and EDX which are clobbered</span><br><span class="line">  pop ecx                    ; Pop off the origional return address our caller will have pushed</span><br><span class="line">  pop edx                    ; Pop off the hash value our caller will have pushed</span><br><span class="line">  push ecx                   ; Push back the correct return value</span><br><span class="line">  jmp eax                    ; Jump into the required function</span><br><span class="line">  ; We now automagically return to the correct caller...</span><br><span class="line">get_next_mod:                ;</span><br><span class="line">  pop eax                    ; Pop off the current (now the previous) modules EAT</span><br><span class="line">get_next_mod1:               ;</span><br><span class="line">  pop edi                    ; Pop off the current (now the previous) modules hash</span><br><span class="line">  pop edx                    ; Restore our position in the module list</span><br><span class="line">  mov edx, [edx]             ; Get the next module</span><br><span class="line">  jmp next_mod               ; Process this module</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="开头注释"><a href="#开头注释" class="headerlink" title="开头注释"></a>开头注释</h2><h3 id="Input-The-hash-of-the-API-to-call-and-all-its-parameters-must-be-pushed-onto-stack"><a href="#Input-The-hash-of-the-API-to-call-and-all-its-parameters-must-be-pushed-onto-stack" class="headerlink" title="Input: The hash of the API to call and all its parameters must be pushed onto stack."></a>Input: The hash of the API to call and all its parameters must be pushed onto stack.</h3><p>这条注释的意思是，你需要在调用这个汇编代码之前，将你想要调用的API的哈希值和它的所有参数按照从右到左的顺序压入栈中。</p>
<h3 id="Output-The-return-value-from-the-API-call-will-be-in-EAX"><a href="#Output-The-return-value-from-the-API-call-will-be-in-EAX" class="headerlink" title="Output: The return value from the API call will be in EAX."></a>Output: The return value from the API call will be in EAX.</h3><p> 这条注释的意思是，当这个汇编代码执行完毕后，它会将调用API的返回值存放在EAX寄存器中。</p>
<h3 id="Clobbers-EAX-ECX-and-EDX-ala-the-normal-stdcall-calling-convention"><a href="#Clobbers-EAX-ECX-and-EDX-ala-the-normal-stdcall-calling-convention" class="headerlink" title="Clobbers: EAX, ECX and EDX (ala the normal stdcall calling convention)"></a>Clobbers: EAX, ECX and EDX (ala the normal stdcall calling convention)</h3><p>这条注释的意思是，这个汇编代码会破坏EAX，ECX和EDX这三个寄存器的原有值，这是符合stdcall调用约定的。</p>
<blockquote>
<p>调用约定是一种规定了函数参数传递和返回值处理方式的约定，不同的调用约定有不同的规则。</p>
</blockquote>
<p>stdcall调用约定是Windows API的标准调用约定，它规定了参数由右到左压入栈中，由被调用者清理栈空间，返回值在EAX中，而EAX，ECX和EDX三个寄存器可以被破坏。</p>
<h3 id="Un-Clobbered-EBX-ESI-EDI-ESP-and-EBP-can-be-expected-to-remain-un-clobbered"><a href="#Un-Clobbered-EBX-ESI-EDI-ESP-and-EBP-can-be-expected-to-remain-un-clobbered" class="headerlink" title="Un-Clobbered: EBX, ESI, EDI, ESP and EBP can be expected to remain un-clobbered."></a>Un-Clobbered: EBX, ESI, EDI, ESP and EBP can be expected to remain un-clobbered.</h3><p>这条注释的意思是，这个汇编代码不会破坏EBX，ESI，EDI，ESP和EBP这五个寄存器的原有值，它们可以被认为是保留不变的。这些寄存器通常被用来保存一些重要的数据或指针，所以在调用一个函数之前或之后，它们应该保持一致。如果一个函数需要破坏这些寄存器，它应该在函数开始时将它们压入栈中，并在函数结束时将它们弹出栈中。</p>
<h3 id="Note-This-function-assumes-the-direction-flag-has-allready-been-cleared-via-a-CLD-instruction"><a href="#Note-This-function-assumes-the-direction-flag-has-allready-been-cleared-via-a-CLD-instruction" class="headerlink" title="Note: This function assumes the direction flag has allready been cleared via a CLD instruction."></a>Note: This function assumes the direction flag has allready been cleared via a CLD instruction.</h3><p>这条注释的意思是，这个汇编代码假设<strong>方向标志位</strong>已经被清除了(通过执行一个CLD指令)。</p>
<p><strong>方向标志位</strong>是一个控制字符串操作指令（如lodsb）方向的标志位，如果它被设置了（通过STD指令），那么字符串操作指令会从高地址向低地址移动；如果它被清除了（通过CLD指令），那么字符串操作指令会从低地址向高地址移动。这个汇编代码使用了lodsb指令来读取模块名和函数名中的每个字节，并计算它们的哈希值。所以它需要方向标志位被清除了，才能正确地读取字符串。</p>
<h3 id="Note-This-function-is-unable-to-call-forwarded-exports"><a href="#Note-This-function-is-unable-to-call-forwarded-exports" class="headerlink" title="Note: This function is unable to call forwarded exports."></a>Note: This function is unable to call forwarded exports.</h3><p>这条注释的意思是，这个汇编代码无法调用<strong>转发导出</strong>的API。</p>
<p><strong>转发导出</strong>是一种导出表中的特殊条目，它不是指向一个<strong>真正的函数地址</strong>，而是指向另一个模块的另一个函数的<strong>名称</strong>。</p>
<p>例如，kernel32.dll中的ExitProcess函数就是一个转发导出，它实际上是指向ntdll.dll中的RtlExitUserProcess函数。这个函数的作用是让你可以使用kernel32.dll中的函数名来调用ntdll.dll中的函数，从而简化你的代码。但是，这个汇编代码无法处理这种情况，因为它只根据哈希值来查找函数地址，而不会解析转发导出的字符串。所以，如果你想要调用转发导出的API，你需要先找到它真正所在的模块和函数名，然后计算它们的哈希值，再传递给这个汇编代码。</p>
<h2 id="api-call"><a href="#api-call" class="headerlink" title="api_call"></a>api_call</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pushad                     ; We preserve all the registers for the caller, bar EAX and ECX.</span><br><span class="line">mov ebp, esp               ; Create a new stack frame</span><br><span class="line">xor edx, edx               ; Zero EDX</span><br><span class="line">mov edx, [fs:edx+0x30]     ; Get a pointer to the PEB</span><br><span class="line">mov edx, [edx+0xc]         ; Get PEB-&gt;Ldr</span><br><span class="line">mov edx, [edx+0x14]        ; Get the first module from the InMemoryOrder module list</span><br></pre></td></tr></table></figure>

<p>**pushad ** </p>
<p>把所有的通用寄存器的值压入栈中，以便在调用API后恢复。</p>
<p><strong>mov ebp, esp</strong></p>
<p>把栈顶指针赋值为栈底指针，相当于创建了一个新的栈帧</p>
<p><strong>xor edx, edx</strong> </p>
<p>清理edx,方便存储PEB指针</p>
<p><strong>mov edx, [fs:edx+0x30]</strong></p>
<p>指令从FS段寄存器中读取PEB的地址，FS段寄存器是一个特殊的寄存器，它指向一个TEB结构(也称作TLS)，该结构包含了一些与当前<strong>线程</strong>相关的信息，其中第0x30个字节就是PEB的地址。</p>
<p>PEB是一个包含了<strong>进程</strong>相关信息的结构体，例如模块列表。</p>
<blockquote>
<p>有关TEB,PEB的学习，可以看以下文章:</p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/267345">从学习Windows PEB到Hell’s Gate-安全客 - 安全资讯平台</a></p>
<p>官方文档:</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-peb">PEB (winternl.h) - Win32 apps | Microsoft Learn</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-teb#members">TEB (winternl.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
<p><strong>mov edx, [edx+0xc]</strong></p>
<p>通过EDX寄存器和偏移量0xc访问PEB中的Ldr成员，将其存入EDX寄存器。Ldr是一个指向_PEB_LDR_DATA结构体的指针，该结构体包含了进程的<strong>已加载模块</strong>的信息。</p>
<p><strong>mov edx, [edx+0x14]</strong> </p>
<p>通过EDX寄存器和偏移量0x14访问<code>_PEB_LDR_DATA</code>中的InMemoryOrderModuleList成员，将其存入EDX寄存器。<code>InMemoryOrderModuleList</code>是一个双向链表的头部(该头部位)，链表中的每个节点都是一个指向_LDR_DATA_TABLE_ENTRY结构体的指针(节点类型是<code>LIST_ENTRY</code>)，该结构体包含了已加载的模块的基址，入口点，全名等信息。</p>
<blockquote>
<p>经过上述操作，EDX寄存器就指向了进程的第一个已加载模块（通常是ntdll.dll）在内存中的顺序链表中的节点(InMemoryOrderLinks)。接下来的代码可以通过遍历这个链表，找到目标模块（例如kernel32.dll）和目标函数（例如LoadLibraryA），然后调用它们。这种方法可以绕过导入表的检测，增加shellcode的隐蔽性和兼容性</p>
</blockquote>
<h2 id="next-mod"><a href="#next-mod" class="headerlink" title="next_mod"></a>next_mod</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">next_mod:                    ;</span><br><span class="line">  mov esi, [edx+0x28]        ; Get pointer to modules name (unicode string)</span><br><span class="line">  movzx ecx, word [edx+0x26] ; Set ECX to the length we want to check</span><br><span class="line">  xor edi, edi               ; Clear EDI which will store the hash of the module name</span><br></pre></td></tr></table></figure>

<p><strong>mov esi, [edx+0x28]</strong> </p>
<p>通过寄存器edx以及偏移量0x28访问LDR_DATA_TABLE_ENTRY的BaseDllName的Buffer,也就是用于存储模块名的缓冲区</p>
<blockquote>
<p>这里有个及其坑的点，就是WIN10版本的SDK，这个结构体为了兼容性改变了一些参数的名称和形式，长这样</p>
<p>typedef struct _LDR_DATA_TABLE_ENTRY {<br>    PVOID Reserved1[2];<br>    LIST_ENTRY InMemoryOrderLinks;<br>    PVOID Reserved2[2];<br>    PVOID DllBase;<br>    PVOID Reserved3[2];<br>    UNICODE_STRING FullDllName;<br>    BYTE Reserved4[8];<br>    PVOID Reserved5[3];</p>
<p>​     ……..</p>
<p>所以我以为找的是FullDllName，然后反复计算反复研究了几个小时得出结果偏移量是0x20(0x28-0x08),然后仔细看了下别的师傅的文章发现其实找的是BaseDllName属性。。。(相当于0x30-0x08&#x3D;0x28)</p>
</blockquote>
<p><strong>movzx ecx, word [edx+0x26]</strong></p>
<p>通过寄存器eax以及偏移量0x26获取模块名称的分配空间的总大小(MaximumLength)</p>
<blockquote>
<p>为什么获取的是MaximumLength，而不是Length，可能是为了方便对齐???</p>
</blockquote>
<p>movzx的zx是零扩展指令,这里为什么要扩展，原因和MaximumLength的数据类型有关</p>
<p>USHORT在头文件的定义是<code>typedef unsigned short USHORT;</code>，也就是说MaximumLength是一个无符号的短整数类型，能表示0-65535的数字，也就是0-2^16,所以是16位的数据类型</p>
<p>而ecx是一个32位的寄存器，所以需要用movzx来将16位的值扩展到32位，同时用0来填充高16位。这样做的目的是为了保证ecx的值是正确的，不会受到高16位的影响。如果不用movzx，而是用mov，那么ecx的高16位就会保留原来的值，可能会导致错误。</p>
<p><strong>xor edi, edi</strong></p>
<p>情况edi寄存器，edi在后面用于存储模块名的哈希值</p>
<blockquote>
<p>经过上述操作,esi寄存器指向了模块名BaseDllName,ecx则指向了模块名的长度</p>
</blockquote>
<h2 id="loop-modname"><a href="#loop-modname" class="headerlink" title="loop_modname"></a>loop_modname</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loop_modname:                ;</span><br><span class="line">  xor eax, eax               ; Clear EAX</span><br><span class="line">  lodsb                      ; Read in the next byte of the name</span><br><span class="line">  cmp al, &#x27;a&#x27;                ; Some versions of Windows use lower case module names</span><br><span class="line">  jl not_lowercase           ;</span><br><span class="line">  sub al, 0x20               ; If so normalise to uppercase</span><br></pre></td></tr></table></figure>

<p><strong>xor eax, eax</strong></p>
<p>清零eax，为下面存放字节内容做准备</p>
<p><strong>lodsb</strong> </p>
<p>读入esi寄存器指向的地址的内容，长度为一个字节，结果存放在AL寄存器，也就是EAX的低8位(1个字节) </p>
<blockquote>
<p>指令执行后esi寄存器会自动加1</p>
</blockquote>
<p><img src="https://lanb0-1305167197.cos.ap-nanjing.myqcloud.com/20230917_1.png"></p>
<p>如图所示,eax存储了程序第一个加载的模块名的第一个字节的内容，这里是<code>P</code>,可能是因为Visual Studio的运行环境决定了第一个模块名并不是ntdll而是程序名</p>
<p>随后esi向后移动了1个字节</p>
<p><strong>cmp al,’a’</strong></p>
<p>某些版本的Windows系统使用小写模块名。因此，代码会检查当前字符的ASCII码是否小于 ‘a’，如果是，则跳转到 ‘not_lowercase’ 标签处的代码，否则，将当前字符减去0x20，这实际上是将其转换为大写（ASCII中，大写字母比对应的小写字母小0x20）。</p>
<blockquote>
<p>loop_modname函数的作用就是读取当前esi指向的模块名的某个字符，并将小写字母转换为大写</p>
</blockquote>
<h2 id="not-lowercase"><a href="#not-lowercase" class="headerlink" title="not_lowercase"></a>not_lowercase</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ror edi, 0xd               ; Rotate right our hash value</span><br><span class="line">add edi, eax               ; Add the next byte of the name</span><br><span class="line">dec ecx</span><br><span class="line">jnz loop_modname           ; Loop until we have read enough</span><br><span class="line">; We now have the module hash computed</span><br><span class="line">push edx                   ; Save the current position in the module list for later</span><br><span class="line">push edi                   ; Save the current module hash for later</span><br><span class="line">; Proceed to iterate the export address table,</span><br><span class="line">mov edx, [edx+0x10]        ; Get this modules base address</span><br><span class="line">mov eax, [edx+0x3c]        ; Get PE header</span><br><span class="line">add eax, edx               ; Add the modules base address</span><br><span class="line">mov eax, [eax+0x78]        ; Get export tables RVA</span><br><span class="line">test eax, eax              ; Test if no export address table is present</span><br><span class="line">jz get_next_mod1           ; If no EAT present, process the next module</span><br><span class="line">add eax, edx               ; Add the modules base address</span><br><span class="line">push eax                   ; Save the current modules EAT</span><br><span class="line">mov ecx, [eax+0x18]        ; Get the number of function names</span><br><span class="line">mov ebx, [eax+0x20]        ; Get the rva of the function names</span><br><span class="line">add ebx, edx               ; Add the modules base address</span><br><span class="line">; Computing the module hash + function hash</span><br></pre></td></tr></table></figure>

<p>**ror edi, 0xd  **</p>
<p>将edi的值以二进制的形式向右平移13位</p>
<blockquote>
<p>一个简单的哈希算法</p>
</blockquote>
<p><strong>add edi, eax</strong> </p>
<p>将eax(实际上是al)的值存入edi,也就是把当前遍历的模块名的字符存入edi寄存器</p>
<blockquote>
<p>因为edi寄存器在next_mod函数中已经清零过，所以在0x000000上加一个值就相当于mov</p>
</blockquote>
<p><strong>dec ecx</strong></p>
<p>ecx自减1，因为ecx存储的是当前BaseDllName的长度，而在上一步已经存入了一个字符，所以长度要减去1</p>
<p><strong>jnz loop_modname</strong></p>
<p>当ecx减到0时，ZF标志位会变为1;反之，当ecx自减后不为0时，ZF标志位会变为0;</p>
<p>所以这个汇编指令的意思就是，当ZF标志位不为0，即ecx自减1后不为0的话,说明模块名还没有遍历完，那么就回到loop_modname函数，继续向edi里添加后续模块名字符</p>
<blockquote>
<p>这里有个疑问，就是如果某个模块名长度大于8个字节，那么该如何存储,毕竟edi只有32位，即使X64的rdi也只能存16个字节</p>
<p>事后看了下一行的作者注释想明白了</p>
<p><code>; We now have the module hash computed</code></p>
<p>意思就是，edi里存储的是模块名的哈希值，这个哈希值有8个字节，并且计算方式就是ror edi, 0xd</p>
</blockquote>
<p><strong>push edx</strong></p>
<p>将edx的值保存在栈中，以便后续调用</p>
<blockquote>
<p>edx的值目前是当前模块列表(InMemoryOrderModuleList)的指针,指向下一个Flink</p>
</blockquote>
<p><strong>push edi</strong> </p>
<p>将edi的值保存在栈中,以便后续调用</p>
<blockquote>
<p>edi的值目前是模块名的哈希值</p>
</blockquote>
<p><strong>mov edx, [edx+0x10]</strong></p>
<p>将edx指向<code>_LDR_DATA_TABLE_ENTRY_</code>结构体的的DllBase,也就是该模块的基址</p>
<blockquote>
<p>在上面已经说了，VS给我加载的第一个模块就是被调试程序本身,所以指向的就是该程序的imageBase(禁用ASLR)</p>
</blockquote>
<p><img src="https://lanb0-1305167197.cos.ap-nanjing.myqcloud.com/20230917_2.png"></p>
<p><strong>mov eax, [edx+0x3c]</strong></p>
<p>获取PE标志的偏移量,即NtHeader的偏移量(AddressOfNewExeHeader)</p>
<p><strong>add eax, edx</strong></p>
<p>将eax(基址)与edx(偏移量)的值相加，获取NT头的实际地址</p>
<p><strong>mov eax, [eax+0x78]</strong></p>
<p>将该模块的导出表的RVA存入eax</p>
<p><strong>test eax, eax</strong> </p>
<p>test是操作数的每一位按逻辑与运算，这里是检测eax是否为全0，即上一步的导出表RVA是否为空，说明导入表不存在</p>
<p><strong>jz get_next_mod1</strong> </p>
<p>该模块导入表为空，直接转入下一个模块</p>
<p><strong>add eax, edx</strong></p>
<p><strong>push eax</strong></p>
<p>获取导出表EAT的实际地址(RVA+imageBase)，并保存入栈</p>
<p><strong>mov ecx, [eax+0x18]</strong></p>
<p><strong>mov ebx, [eax+0x20]</strong> </p>
<p>获取以<code>名称</code>方式导出的函数的总数<code>NumberOfNames</code>以及存储了有名称导出函数RVA的<code>AddressOfNames</code>的RVA</p>
<p>导出表EAT的数据结构如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_EXPORT_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   Characteristics; <span class="comment">//0x00</span></span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;  <span class="comment">//0x18</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<ul>
<li>NumberOfFunctions表示导出表中导出函数的总数，也就是AddressOfFunctions数组的长度。AddressOfFunctions数组存放了每个导出函数的相对虚拟地址（RVA），可以通过这个地址找到函数在内存中的位置。</li>
<li>NumberOfNames表示导出表中<strong>有名称</strong>的导出函数的个数，也就是AddressOfNames和AddressOfNameOrdinals数组的长度。AddressOfNames数组存放了每个有名称的导出函数的名称字符串的RVA，可以通过这个地址找到函数名在内存中的位置。AddressOfNameOrdinals数组存放了每个有名称的导出函数在AddressOfFunctions数组中的索引，可以通过这个索引找到对应的函数地址。</li>
</ul>
<p>这两个字段的值可能不相等，因为有些导出函数可能没有名称，只能通过序号来访问。</p>
<blockquote>
<p>此时，各寄存器状态如下</p>
<p>eax:导出表EAT的实际地址(RVA+ImageBase)</p>
<p>ebx:AddressOfNames(有名称的导出函数表)的RVA</p>
<p>ecx:NumberOfNames(有名称的导出函数的数量)</p>
<p>edx:当前模块基址</p>
</blockquote>
<p><strong>add ebx, edx</strong>  </p>
<p>将AddressOfNames(有名称的导出函数表)加上基址的实际地址存入ebx</p>
<p>经过上述操作,就完成了整个<code>not_lowercase</code>函数的操作，该函数可以主要划分为两个部分</p>
<p>第一部分:</p>
<ol>
<li>先挨个读取当前模块名，并同时进行简单移位操作的哈希运算，将最后的结果入栈保存</li>
<li>将指向当前模块的指针和模块名哈希结果入栈保存</li>
</ol>
<p>第二部分:</p>
<ol>
<li>找到当前模块的基址</li>
<li>获取导出表EAT的RVA</li>
<li>将基址与RVA相加，获取EAT的实际地址</li>
<li>获取导出表结构体里的有名导出函数的个数(NumberOfNames)，以及有名导出函数数组AddressOfNames的RVA</li>
<li>将基址与RVA相加, 获取AddressOfNames的实际地址</li>
</ol>
<p><strong>get_next_func</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">get_next_func:               ;</span><br><span class="line">  test ecx, ecx              ; Changed from jecxz to accomodate the larger offset produced by random jmps ;								 ;below</span><br><span class="line">  jz get_next_mod            ; When we reach the start of the EAT (we search backwards), process the next 								 ;module</span><br><span class="line">  dec ecx                    ; Decrement the function name counter</span><br><span class="line">  mov esi, [ebx+ecx*4]       ; Get rva of next module name</span><br><span class="line">  add esi, edx               ; Add the modules base address</span><br><span class="line">  xor edi, edi               ; Clear EDI which will store the hash of the function name</span><br><span class="line">  ; And compare it to the one we want</span><br></pre></td></tr></table></figure>

<p><strong>test ecx, ecx</strong> </p>
<p><strong>jz get_next_mod</strong></p>
<p>ecx寄存器存储的NumberOfNames的值，自身与运算后如果全为0，则说明NumberOfNames为0，即该模块没有<strong>有名导出函数</strong>,直接跳转到下一个模块</p>
<blockquote>
<p>这里猜测可能无法利用序号来使用导出函数，所以必须使用有名导出函数?</p>
</blockquote>
<p><strong>dec ecx</strong></p>
<p>NumberOfNames减1，因为正在获取一个导出函数</p>
<p><strong>mov esi, [ebx+ecx*4]</strong></p>
<p><strong>add esi, edx</strong></p>
<p>这里目前没明白啥意思，官方给出的注释是<code>Get rva of next module name</code>,但是我们都知道，[ebx+ecx*4]表示的是AddressOfNames这个数组最后一个成员，指向的RVA是一个导出函数的名字，这里为什么要用module???</p>
<p><strong>xor edi, edi</strong></p>
<p>将edi清零</p>
<p><strong>get_next_func函数的作用就是获取当前模块的有名导出函数(从最后一个开始)的实际地址</strong></p>
<p><strong>loop_funcname</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">loop_funcname:               ;</span><br><span class="line">  xor eax, eax               ; Clear EAX</span><br><span class="line">  lodsb                      ; Read in the next byte of the ASCII function name</span><br><span class="line">  ror edi, 0xd               ; Rotate right our hash value</span><br><span class="line">  add edi, eax               ; Add the next byte of the name</span><br><span class="line">  cmp al, ah                 ; Compare AL (the next byte from the name) to AH (null)</span><br><span class="line">  jne loop_funcname          ; If we have not reached the null terminator, continue</span><br><span class="line">  add edi, [ebp-8]           ; Add the current module hash to the function hash</span><br><span class="line">  cmp edi, [ebp+0x24]        ; Compare the hash to the one we are searchnig for</span><br><span class="line">  jnz get_next_func          ; Go compute the next function hash if we have not found it</span><br><span class="line">  ; If found, fix up stack, call the function and then value else compute the next one...</span><br><span class="line">  pop eax                    ; Restore the current modules EAT</span><br><span class="line">  mov ebx, [eax+0x24]        ; Get the ordinal table rva</span><br><span class="line">  add ebx, edx               ; Add the modules base address</span><br><span class="line">  mov cx, [ebx+2*ecx]        ; Get the desired functions ordinal</span><br><span class="line">  mov ebx, [eax+0x1c]        ; Get the function addresses table rva</span><br><span class="line">  add ebx, edx               ; Add the modules base address</span><br><span class="line">  mov eax, [ebx+4*ecx]       ; Get the desired functions RVA</span><br><span class="line">  add eax, edx               ; Add the modules base address to get the functions actual VA</span><br><span class="line">  ; We now fix up the stack and perform the call to the desired function...</span><br></pre></td></tr></table></figure>



<p><strong>xor eax,eax</strong></p>
<p><strong>lodsb</strong></p>
<p>将eax清零,然后将esi指向的地址的内容读入al，即把AddressOfNames数组的当前元素指向的函数名rva读入到eax的前2个字节(8位)</p>
<blockquote>
<p>Read in the next byte of the ASCII function name </p>
<p>这里的注释也佐证了我上面的推测，编写这个代码的人是不是把next function name 错写成了 next module name</p>
</blockquote>
<p><strong>ror edi, 0xd</strong></p>
<p>将当前已读入的函数名做一个同样的移位哈希</p>
<p><strong>add edi, eax</strong></p>
<p>将当前eax中的函数名字符加到edi寄存器中</p>
<p><strong>cmp al, ah</strong> </p>
<p><strong>jne loop_funcname</strong></p>
<p>将eax的低8位(al)与高8位(ah)比较，因为eax的高8位一直为0x00,即null结束符，所以如果al也为0，则说明读到了字符串的结束符，结束循环，否则继续回到开始读后面的字节</p>
<p><strong>add edi, [ebp-8]</strong></p>
<p>[ebp-8]存储的是当前模块的哈希，这里相当于为函数名加个模块的盐，可以理解为hash(func+module)，进一步保证唯一性</p>
<p><strong>cmp edi, [ebp+0x24]</strong></p>
<p>把当前遍历的函数哈希与需要的函数哈希做对比，来判断是否找到了所需的函数</p>
<blockquote>
<p> [ebp+0x24]这个地址有什么特殊意义目前想不到，可能开发者是在别的block中提前把需要的函数哈希计算好放在了这个位置????</p>
<p> [ebp+0x20]是旧eax的状态，那么再加0x4就是处于旧eax之前的地址，这个地址的状态无法知晓，所以我猜测这是开发者可能在之前规定好的存放需要search的函数哈希</p>
</blockquote>
<p><strong>jnz get_next_func</strong></p>
<p>如果不是我们要找的函数，就跳过后面的流程，跳到当前模块的下一个导出函数</p>
<p><strong>pop eax</strong> </p>
<p>将当前模块的导出表EAT的实际地址出栈，并保存在eax中</p>
<p><strong>mov ebx, [eax+0x24]</strong></p>
<p><strong>add ebx, edx</strong> </p>
<p>获取<code>AddressOfNameOrdinals</code>的实际地址</p>
<p>*<em>mov cx, [ebx+2</em>ecx] **</p>
<p>AddressOfNameOrdinals数组的每一项为WORD，这里就是获取当前有名导出函数在AddressOfFunctions中的序号</p>
<p><strong>mov ebx, [eax+0x1c]</strong></p>
<p><strong>add ebx, edx</strong> </p>
<p>获取<code>AddressOfFunctions</code>的实际地址</p>
<p><strong>mov eax, [ebx+4*ecx]</strong></p>
<p><strong>add eax, edx</strong> </p>
<p>从<code>AddressOfFunctions</code>中获取当前导出函数的RVA,然后加上基址，得到当前导出函数的实际地址</p>
<p><strong>总结一下loop_funcname函数的流程</strong></p>
<ol>
<li>获取当前遍历的导出函数名</li>
<li>为了保证唯一性，将该函数名与模块做哈希运算</li>
<li>将(2)中获取到的哈希结果与我们正在寻找的函数名哈希做对比，如果相同，则继续下面的步骤，否则直接遍历下一个导出函数</li>
<li>通过AddressOfNameOrdinals找出当前导出函数的序号，然后在AddressOfFunctions中找到该导出函数的RVA</li>
<li>将(4)中的结果与基址相加，得到我们想要的导出函数的实际地址</li>
</ol>
<p><strong>finish</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">finish:</span><br><span class="line">  mov [esp+0x24], eax        ; Overwrite the old EAX value with the desired api address for the upcoming popad</span><br><span class="line">  pop ebx                    ; Clear off the current modules hash</span><br><span class="line">  pop ebx                    ; Clear off the current position in the module list</span><br><span class="line">  popad                      ; Restore all of the callers registers, bar EAX, ECX and EDX which are clobbered</span><br><span class="line">  pop ecx                    ; Pop off the origional return address our caller will have pushed</span><br><span class="line">  pop edx                    ; Pop off the hash value our caller will have pushed</span><br><span class="line">  push ecx                   ; Push back the correct return value</span><br><span class="line">  jmp eax                    ; Jump into the required function</span><br><span class="line">  ; We now automagically return to the correct caller...</span><br><span class="line">get_next_mod:                ;</span><br><span class="line">  pop eax                    ; Pop off the current (now the previous) modules EAT</span><br><span class="line">get_next_mod1:               ;</span><br><span class="line">  pop edi                    ; Pop off the current (now the previous) modules hash</span><br><span class="line">  pop edx                    ; Restore our position in the module list</span><br><span class="line">  mov edx, [edx]             ; Get the next module</span><br><span class="line">  jmp next_mod               ; Process this module</span><br></pre></td></tr></table></figure>

<blockquote>
<p>终于到结尾，真不容易。:)</p>
</blockquote>
<p><strong>mov [esp+0x24], eax</strong> </p>
<p>将所需的导出函数的实际地址放入旧eax中，即 [esp+0x24]</p>
<p><strong>pop ebx</strong> </p>
<p><strong>pop ebx</strong></p>
<p>清空记录module位置和记录模块哈希的栈帧,以免影响下一步的寄存器状态还原</p>
<p><strong>popad</strong> </p>
<p>对应第1步PUSHAD指令的逆操作,用于恢复CPU的环境变量</p>
<blockquote>
<p>POPAD指令按照与PUSHAD相反的顺序依次弹出寄存器的值。顺序为</p>
<p>EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX.</p>
</blockquote>
<p>执行完这一步后，所有的寄存器状态都回归于执行这个汇编程序之前的状态，除了eax存储的仍然是导出函数的实际地址</p>
<p><strong>pop ecx</strong></p>
<p><strong>pop edx</strong></p>
<p>没看懂，因为旧栈帧的具体情况我们从这上下文中无法获知，所以从旧栈帧中出栈的元素也无法获知是什么</p>
<p><strong>push ecx</strong></p>
<p>把旧栈帧的第一个元素入栈，仍然没看懂</p>
<p><strong>jmp eax</strong></p>
<p>jmp到我们找到的那个函数地址然后开始执行</p>
<p><strong>get_next_mod</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_next_mod:                ;</span><br><span class="line">  pop eax                    ; Pop off the current (now the previous) modules EAT</span><br></pre></td></tr></table></figure>

<p>这里衔接的是<code>get_next_func</code>中对应的没有有名导出函数时的情况，就把栈中刚push的导出表EAT的实际地址再pop出去</p>
<p><strong>get_next_mod1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get_next_mod1:               ;</span><br><span class="line">  pop edi                    ; Pop off the current (now the previous) modules hash</span><br><span class="line">  pop edx                    ; Restore our position in the module list</span><br><span class="line">  mov edx, [edx]             ; Get the next module</span><br><span class="line">  jmp next_mod               ; Process this module</span><br></pre></td></tr></table></figure>

<p>这里衔接的是<code>not_lowercase</code>中对应的当前模块没有导出表时的情况，将当前模块的哈希和位置出栈。</p>
<p><strong>mov edx, [edx]</strong> </p>
<p>获取下一个模块module的位置</p>
<blockquote>
<p>此前edx为_LIST_ENTRY中的*Flink,Flink中存储的是下一个Flink的地址,相当于指向了下一个模块的地址</p>
</blockquote>
<p><strong>jmp next_mod</strong>  </p>
<p>跳转到 <code>next_mod</code>，开始下一个模块的循环</p>
<h1 id="流程图概述"><a href="#流程图概述" class="headerlink" title="流程图概述"></a>流程图概述</h1><p><img src="https://lanb0-1305167197.cos.ap-nanjing.myqcloud.com/20230928_1.jpg"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wustzhb.github.io">lanb0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wustzhb.github.io/2023/09/28/[%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0]MSF%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84Shellcode%E5%AD%A6%E4%B9%A0/">https://wustzhb.github.io/2023/09/28/[%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0]MSF%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84Shellcode%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wustzhb.github.io" target="_blank">Lanb0's blog|一个默默无闻的网安爱好者</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%8D%E6%9D%80/">免杀</a><a class="post-meta__tags" href="/tags/MSF/">MSF</a></div><div class="post_share"><div class="social-share" data-image="/img/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/09/24/%5BJS%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83%5DSecure%20Portal/" title="[JS专项训练]Secure Portal"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">[JS专项训练]Secure Portal</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/01/%5B%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%5D%E7%BD%91%E7%BB%9C%E6%9F%A5%E6%9D%80%E4%B8%8E%E8%A7%84%E9%81%BF/" title="[免杀学习]网络查杀与规避"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-01</div><div class="title">[免杀学习]网络查杀与规避</div></div></a></div><div><a href="/2023/08/28/%5B%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%5DYara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0/" title="[免杀学习]Yara规则学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-28</div><div class="title">[免杀学习]Yara规则学习</div></div></a></div><div><a href="/2023/06/25/%5B%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%5D%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9D%E6%8E%A2(%E4%B8%8A)/" title="[免杀学习]动态链接库初探(上)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-25</div><div class="title">[免杀学习]动态链接库初探(上)</div></div></a></div><div><a href="/2023/06/26/%5B%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%5D%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9D%E6%8E%A2(%E4%B8%8B)/" title="[免杀学习]动态链接库初探(下)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-26</div><div class="title">[免杀学习]动态链接库初探(下)</div></div></a></div><div><a href="/2023/07/18/%5B%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%5D%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6%E6%89%AB%E6%8F%8F%E6%B5%85%E6%9E%90(%E4%B8%8A)/" title="[免杀学习]杀毒软件扫描浅析(上)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-18</div><div class="title">[免杀学习]杀毒软件扫描浅析(上)</div></div></a></div><div><a href="/2023/07/30/%5B%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%5D%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6%E6%89%AB%E6%8F%8F%E6%B5%85%E6%9E%90(%E4%B8%8B)/" title="[免杀学习]杀毒软件扫描浅析(下)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-30</div><div class="title">[免杀学习]杀毒软件扫描浅析(下)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lanb0</div><div class="author-info__description">充实地过好每一天</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=Ga7oV2UM08biI8VudKTeFcEdzYPbbXdz&amp;noverify=0&amp;personal_qrcode_source=4" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">没什么大事要宣布的</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#block-api"><span class="toc-number">1.</span> <span class="toc-text">block_api</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A4%B4%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.</span> <span class="toc-text">开头注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Input-The-hash-of-the-API-to-call-and-all-its-parameters-must-be-pushed-onto-stack"><span class="toc-number">1.1.1.</span> <span class="toc-text">Input: The hash of the API to call and all its parameters must be pushed onto stack.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Output-The-return-value-from-the-API-call-will-be-in-EAX"><span class="toc-number">1.1.2.</span> <span class="toc-text">Output: The return value from the API call will be in EAX.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clobbers-EAX-ECX-and-EDX-ala-the-normal-stdcall-calling-convention"><span class="toc-number">1.1.3.</span> <span class="toc-text">Clobbers: EAX, ECX and EDX (ala the normal stdcall calling convention)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Un-Clobbered-EBX-ESI-EDI-ESP-and-EBP-can-be-expected-to-remain-un-clobbered"><span class="toc-number">1.1.4.</span> <span class="toc-text">Un-Clobbered: EBX, ESI, EDI, ESP and EBP can be expected to remain un-clobbered.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Note-This-function-assumes-the-direction-flag-has-allready-been-cleared-via-a-CLD-instruction"><span class="toc-number">1.1.5.</span> <span class="toc-text">Note: This function assumes the direction flag has allready been cleared via a CLD instruction.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Note-This-function-is-unable-to-call-forwarded-exports"><span class="toc-number">1.1.6.</span> <span class="toc-text">Note: This function is unable to call forwarded exports.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api-call"><span class="toc-number">1.2.</span> <span class="toc-text">api_call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#next-mod"><span class="toc-number">1.3.</span> <span class="toc-text">next_mod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop-modname"><span class="toc-number">1.4.</span> <span class="toc-text">loop_modname</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#not-lowercase"><span class="toc-number">1.5.</span> <span class="toc-text">not_lowercase</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">流程图概述</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/28/%5B%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%5DMSF%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84Shellcode%E5%AD%A6%E4%B9%A0/" title="[免杀学习]MSF框架分析之Windows Api的调用">[免杀学习]MSF框架分析之Windows Api的调用</a><time datetime="2023-09-28T12:00:00.000Z" title="发表于 2023-09-28 20:00:00">2023-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/24/%5BJS%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83%5DSecure%20Portal/" title="[JS专项训练]Secure Portal">[JS专项训练]Secure Portal</a><time datetime="2023-09-23T17:06:00.000Z" title="发表于 2023-09-24 01:06:00">2023-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/23/%5BJS%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83%5DFile%20Library/" title="[JS专项训练]File Library WP">[JS专项训练]File Library WP</a><time datetime="2023-09-23T10:01:00.000Z" title="发表于 2023-09-23 18:01:00">2023-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/02/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86/" title="PE结构分析">PE结构分析</a><time datetime="2023-09-02T04:32:00.000Z" title="发表于 2023-09-02 12:32:00">2023-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/28/%5B%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%5DYara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0/" title="[免杀学习]Yara规则学习">[免杀学习]Yara规则学习</a><time datetime="2023-08-28T04:41:00.000Z" title="发表于 2023-08-28 12:41:00">2023-08-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/index_img.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By lanb0</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到lanb0的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>